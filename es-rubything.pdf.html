<!DOCTYPE html>
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>Taller de Ruby/Rails</title>
   
   

<style>
html, body { margin: 0; padding: 0; }

body { font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; }

a:link, a:visited { color: black; }

h1 { font-size: 30pt;  }
h2 { font-size: 28pt;  }
h3 { font-size: 25pt;  }
p, li, dt, dd, td, th { font-size: 18pt; }

pre { font-size: 14pt;  }
pre.small { font-size: 11pt; }

pre.code {
        background-color: azure;
        padding: 5px;
      }
     
ul { list-style-type: square; }    
   
.center { text-align: center; }   
     
.slide { page-break-after: always;
         min-height: 100mm;
         padding: 40px;
         
         border: 1px dotted black;

/*      
  background: -moz-linear-gradient( top, maroon, red);
*/
       }


body {
    font-family: 'Helvetica Neue', Helvetica, sans-serif;
}

.slide h2 {
    font-size: 24pt;
}

table td {
    padding: .5em;
    border: 1px solid #ccc;
}



/*
for princexml (CSS3 paged media support)
@page { size: A4 landscape }
*/
</style>

</head>
<body>

<div class="presentation">

<div class='slide '>
<h1>Aprendiendo Ruby and Rails</h1><p>Buenos Días!</p>

</div>
<div class='slide '>
<h1>Presentaciones</h1><ul>
	<li>Devchix : devchix@ y www.devchix.com</li>
	<li>RailsBridge en la comunidad Ruby/Rails</li>
	<li>PyStar en la comunidad Python</li>
	<li>En Montevideo gente de Cubox, WyeWorks y Moove-it</li>
</ul>

</div>
<div class='slide '>
<h1>Agenda del Día</h1><ul>
	<li>9:00 <strong>Presentaciones</strong></li>
	<li>9:30 &#8211; 13:00 <strong>Instalación del ambiente de trabajo</strong></li>
	<li>10:30 -11:30 <strong>Introducción a Ruby</strong></li>
	<li>11:30 -12:00 <strong>Ruby Koans</strong></li>
	<li>12:00 -1:00 <strong>Almuerzo</strong></li>
	<li>1:00 &#8211; <strong>Rails parte 1</strong></li>
	<li>2:45 -3:00 <strong>Descanso</strong></li>
	<li>3:00 -4:30 <strong>Rails parte 2</strong></li>
	<li>4:30 <strong>Y ahora? Contribuyendo con Rails</strong></li>
</ul>

</div>
<div class='slide '>
<h1>Qué Temas Vamos a Cubrir?</h1><ul>
	<li>Ruby</li>
	<li>Instalando el ambiente de trabajo</li>
	<li>Sintaxis y operaciones simples en Ruby
	<ul>
		<li>Objetos, clases, modulos y métodos</li>
		<li>Testing en Ruby</li>
		<li>Bloques y estructuras de control</li>
		<li>Expresiones regulares</li>
		<li>Excepciones</li>
	</ul></li>
	<li>Una introducción a Rails
	<ul>
		<li>Un tour desde la consola de Rails</li>
		<li>Modelos</li>
		<li>Vistas</li>
		<li>Controladores</li>
	</ul></li>
</ul>

</div>
<div class='slide '>
<h1>Ruby</h1><ul>
	<li>Originado en Japón a mediados de los 90, su creador es Yukihiro &#8220;Matz&#8221; Matsumoto. Está inspirado en Perl, Lisp entre otros lenguajes</li>
	<li>&#8220;I wanted a scripting language that was more powerful than Perl, and more object-oriented than Python. That&#8217;s why I decided to design my own language&#8221;.</li>
	<li>Ruby es un lenguaje
	<ul>
		<li>dinamico</li>
		<li>reflexivo</li>
		<li>orientado a objetos</li>
		<li>open source</li>
	</ul></li>
	<li>Hay diferentes implementaciones del lenguaje
	<ul>
		<li>MRI (mat&#8217;z ruby interpreter) es la referencia que hay de Ruby. Está escrito en C</li>
		<li>JRuby es una implementación hecha en Java</li>
		<li>IronRuby corre sobre .NET. Es desarrollado por Microsoft bajo la Apache License.</li>
		<li>Rubinius esta hecho en Ruby</li>
	</ul></li>
	<li>Versiones
	<ul>
		<li>1.8.7</li>
		<li>1.9.2 &lt;&#8212; recomendada</li>
	</ul></li>
</ul>

</div>
<div class='slide '>
<h1>Porque Ruby?</h1><ul>
	<li>&#8220;Lenguajes de Programación deben sentirse natural para los programadores.&#8221;</li>
	<li>La comunidad de Ruby en Montevideo está creciendo</li>
	<li>Tiene RubyGems que es el sistema usado para empaquetar y distribuir código Ruby</li>
	<li>Rails es un web framework bastante popular construido sobre Ruby</li>
	<li>En 10 años se han agregado una gran cantidad de clases y modulos nativos al lenguaje.</li>
	<li>Tiene buenas herramientas para testing como RSpec y Cucumber.</li>
</ul>

</div>
<div class='slide '>
<h1>Instalando el ambiente de trabajo</h1><ul>
	<li>Todos se sienten comodos manejando una terminal?</li>
	<li>En linux ó Mac (tener el sistema actualizado e instalado curl y git)
	<ul>
		<li>RVM: Te permite manejar multiples interpretes de Ruby en la misma máquina y fácilmente cambiar entre versiones.
		<ul>
			<li><code>bash &lt; &lt;( curl http://rvm.beginrescueend.com/releasesl/rvm-install-head )</code></li>
			<li>Seguir las instrucciones para agregar rvm al .bashrc</li>
			<li><code>source $HOME/.rvm/scripts/rvm</code></li>
			<li><code>rvm notes</code></li>
		</ul></li>
	</ul></li>
	<li>En Windows hay que instalar primero Ruby
	<ul>
		<li>Ruby: Vamos a usar la version 1.9.2 y el interprete MRI
		<ul>
			<li>Ir a http://rubyinstaller.org y descargar la versión de Ruby mediante el botón Download.</li>
			<li>Ejecutarla y comenzar la intalación</li>
		</ul></li>
	</ul></li>
</ul>

</div>
<div class='slide '>
<h1>Instalando el ambiente de trabajo</h1><ul>
	<li>En Linux ó Mac
	<ul>
		<li>Ruby: para este taller usaremos mri y la versión 1.9.2
		<ul>
			<li><code>rvm install 1.9.2</code></li>
			<li>mirar rvm help para ver que más se puede hacer</li>
		</ul></li>
	</ul></li>
</ul>

</div>
<div class='slide '>
<h1>Instalando el ambiente de trabajo</h1><ul>
	<li>En Windows
	<ul>
		<li>PIK: Te permite manejar multiples interpretes de Ruby en la misma máquina y fácilmente cambiar entre versiones.
		<ul>
			<li>Descargar la última versión http://github.com/vertiginous/pik/downloads</li>
			<li>Seguir los pasos de la instalación</li>
			<li>Deslogueate o reinicia windows para integrar pik al ambiente.</li>
			<li>En una terminal
			<ul>
				<li><code>pik add</code></li>
				<li><code>pik list</code></li>
				<li><code>pik use 192</code></li>
				<li><code>ruby -v</code></li>
			</ul></li>
		</ul></li>
		<li>Ó Ruby Installer: Un ejecutable que instala Ruby y Ruby Gems
		<ul>
			<li>Descargar la ultima verisón de http://rubyinstaller.org</li>
			<li>Seguir los pasos de la instalación</li>
			<li>Instalar pik mediante @gem install pik</li>
		</ul></li>
	</ul></li>
</ul>

</div>
<div class='slide '>
<h1>Instalando el ambiente de trabajo</h1><ul>
	<li>Instalar Ruby Gems
	<ul>
		<li>En Linux
		<ul>
			<li>@apt-get install rubygems</li>
		</ul></li>
		<li>En Windows RubyInstaller ya viene con Ruby Gems</li>
	</ul></li>
	<li>Rails: Vamos a usar la version 3.1
		<ul>
			<li>@gem install rails</li>
		</ul></li>
</ul>
<ul>
	<li>Editores: Trabajen en el que se sientan más comodos
	<ul>
		<li>VIM</li>
		<li>Textmate</li>
		<li>Emacs</li>
		<li>Gedit</li>
		<li>Eclipse</li>
		<li>NetBeans</li>
		<li>RubyMine</li>
	</ul></li>
</ul>

</div>
<div class='slide '>
<h1>Abriendo el interprete de Ruby</h1><p>Abrir una terminal y ejecutar irb.</p>
<p>Jugar un poco:</p>
<pre><code>1
4 + 3 
"hat" 
[1, 2, 3, "happy"].each { |i| puts i }</code></pre>
<p><code>&gt;&gt;</code> es donde ingresas comandos y en <code>=&gt;</code> va a aparecer la respuesta.</p>
<p>irb tiene un historial de comandos. Usen las flechitas para navegarlo.</p>

</div>
<div class='slide '>
<h1>Datos Básicos de Ruby</h1><table>
	<tr>
		<td>Integers</td>
		<td> <code>1</code>, <code>2</code>, <code>3</code> </td>
	</tr>
	<tr>
		<td>Strings </td>
		<td> <code>"chicken"</code> </td>
	</tr>
	<tr>
		<td>Booleans</td>
		<td> <code>true</code>, <code>false</code> </td>
	</tr>
	<tr>
		<td>Symbols </td>
		<td> <code>:chicken</code> </td>
	</tr>
	<tr>
		<td>Arrays  </td>
		<td> <code>[1, 7, "cake"]</code> </td>
	</tr>
	<tr>
		<td>Hashes  </td>
		<td> <code>{:chicken =&gt; "chicken", :sillyexample =&gt; :chicken}</code> </td>
	</tr>
</table>
<p>En Ruby <i>casi todo</i> es un objeto. A un objeto se le puede enviar los mensajes a los que el objeto puede responder. A grandes rasgos a esto le llamamos &#8220;duck typing&#8221;. Si un objeto camina como un pato y habla como un pato, entonces el interprete lo trata como un pato.
Juega con la terminal!</p>

</div>
<div class='slide '>
<h1>Datos Básicos en Ruby</h1><ul>
	<li>En Java <code>min = Math.abs(num)</code></li>
	<li>En Ruby <code>postive = num.abs</code></li>
</ul>
<ul>
	<li>En C <code>strlen(name)</code></li>
	<li>En Ruby <code>name.lenght</code></li>
</ul>
<p>Le enviamos un mensaje al propio objeto. Y lo mismo aplica a toods los objetos en Ruby.</p>
<p>En Ruby, NIL es un objeto que representa ausencia de valor.</p>

</div>
<div class='slide '>
<h1>Operaciones basicas en ruby</h1><table>
	<tr>
		<td> <code>2 + 2</code> </td>
		<td> <code>4</code> </td>
	</tr>
	<tr>
		<td> <code>3 * 3</code> </td>
		<td> <code>9</code> </td>
	</tr>
	<tr>
		<td> <code>"chicken".reverse</code> </td>
		<td> <code>"nekcihc"</code> </td>
	</tr>
	<tr>
		<td> <code>"chicken".length</code>  </td>
		<td> <code>7</code> </td>
	</tr>
	<tr>
		<td> <code>2 + 2 == 4</code> </td>
		<td> <code>true</code> </td>
	</tr>
	<tr>
		<td> <code>2 + 2 == 5</code> </td>
		<td> <code>false</code> </td>
	</tr>
	<tr>
		<td> <code>[1, 2, 3].include?(2)</code> </td>
		<td> <code>true</code> </td>
	</tr>
</table>
<p>Y que es lo que hace <code>"chicken".reverse.length</code> ?
Y <code>"puppy".include?("p")</code>?</p>

</div>
<div class='slide '>
<h1>Interpolación de Expresiones</h1><p>Algo que Ruby hace con strings entre comillas dobles es interpolacion de expresiones. Es decir, dentro de un string la secuencia <code>#{expression}</code> es reemplazada por el valor de la expresión.</p>
<p>Por ejemplo, prueba</p>
<pre><code>@"Nuestro array es #{[1,2,3]}"@</code></pre>
<p>Ó</p>
<pre><code>var = [1,2,3,4,5,6]
"Nuestro array es #{var}"</code></pre>

</div>
<div class='slide '>
<h1>Variables</h1><p>Las variables son implícitas y declaradas.</p>
<p>Qué pasa en cada paso?</p>
<pre><code>thing = "chicken"
thing
thing.reverse
thing
thing = thing.reverse</code></pre>

</div>
<div class='slide '>
<h1>Variables</h1><p>Intenten.</p>
<pre><code>awesome_list = [5,2,1,8]
awesome_list.sort!
awesome_list</code></pre>
<p>Como paso esto? Acciones que terminen con un <code>!</code> &#8220;cambian&#8221; los datos!
Esto es una convención de Ruby, pero una buena a seguir.</p>

</div>
<div class='slide '>
<h1>Convenciones para Variables y Alcance</h1><ul>
	<li>locales:  comienzan con minúscula o guión bajo</li>
	<li>globales: comienzan con $</li>
	<li>de instancia: comienzan con @</li>
	<li>de clase: comienzan con @@</li>
	<li>de más de una palabra se escriben con guión bajo. Ej. user_name</li>
	<li>constantes en mayúscula</li>
</ul>
<p>Hay tres lugares donde el alcance cambia: las definiciones de clases (<code>class</code>), las definiciones de modulos (<code>module</code>) y los métodos (<code>def</code>)</p>

</div>
<div class='slide '>
<h1>Símbolos</h1><p>Son etiquetas que no hay que pre-declarar y que son únicas. Empieza con <code>:</code> y es seguido por un nombre. Ruby garantiza que en cualquier parte del programa en donde aparezca el símbolo va a tener el mismo valor. Son usualmente usados como llaves de un hash.</p>
<p>Por ejemplo:</p>
<ul>
	<li><code>:norte</code></li>
	<li><code>:sur</code></li>
</ul>

</div>
<div class='slide '>
<h1>Hashes</h1><ul>
	<li>También es un tipo nativo del lenguaje.</li>
	<li>Al igual que los arrays son colecciones indexadas.</li>
	<li>Las llaves de los arrays deben ser integer pero los hashes pueden tener cualquier objeto como llave.</li>
	<li>Pueden contener diferentes tipos de elemento en el mismo array/hash.</li>
	<li>Por defecto el valor para nil en un hash es false. Se puede cambiar al crear el hash.</li>
	<li>En Ruby 1.9 se introduce un nuevo sintaxis para hashes</li>
</ul>
<pre><code>frutas_color = {
  naranja:  "naranja",
  frutilla: "rojo",
  banana:   "amarillo
}</code></pre>
<p><code>frutas_color[:frutilla]</code> produce <code>"rojo"</code></p>
<p>También conocidos como Map, Associative Array, Dictionary, Key/Value Pair Store</p>

</div>
<div class='slide '>
<h1>Hashes</h1><p>Consideremos un sistema de rating de libros:</p>
<ul>
	<li>Usamos valores numericos 0-5 para valorar un libro que hemos leido.</li>
	<li><code>:not_rated</code> va a representar un libro que aún no ha sido valorado.</li>
	<li>Vamos a guardar los datos en un hash.</li>
</ul>
<p>Crea un hash y agregale algunos libros, por ejemplo:</p>
<pre><code>books = { "Left Hand of Darkness"        =&gt; 5,
              "The Word for World Is Forest" =&gt; 5,
              "Nevermind the Pollacks"       =&gt; 0,
              "Only Revolutions"             =&gt; :not_rated 
	    }</code></pre>

</div>
<div class='slide '>
<h1>Hashes</h1><p>Vamos a obtener el rating de un libro en particular con</p>
<p><code>books["Left Hand of Darkness"]</code></p>
<p>También podemos <strong>guardar</strong> valores con</p>
<p><code>books["Only Revolutions"] = 3</code></p>
<p>Agregamos un libro de la misma forma</p>
<p><code>books["White Teeth"] = 4</code></p>
<p>Y con <code>books</code> vemos todo el hash</p>
<p>Jueguen con el hash en irb</p>

</div>
<div class='slide '>
<h1>Métodos</h1><p><code>40.reverse</code></p>
<p>Qué pasa?</p>
<p>Ruby dijo <code>NoMethodError: undefined method `reverse' for 40:Fixnum</code></p>
<p>Significa que <code>reverse</code> no es un método que podamos aplicar al número 40</p>

</div>
<div class='slide '>
<h1>métodos</h1><p>Los métodos son invocados al enviarles un mensaje al objeto. El mensaje contiene el nombre del método asi como cualquier parametro que este necesite.</p>
<p>Si quieren ver los métodos de un objeto pueden escribir <code>40.methods.sort</code></p>

</div>
<div class='slide '>
<h1>Objetos</h1><p>Nuevamente, todo lo que manipulas en Ruby es un objeto y los resultados de esas manipulaciones tambien son objetos. Cada objeto tiene un identificador único.</p>
<p>Un objeto son los datos asi como tambien los métodos que se le puede aplicar.</p>
<p>Un objeto es una estructura con identidad, estado y un comportamiento definidos.</p>
<p>Como averiguamos la clase origen de un objeto? Sólo hay que preguntarle!</p>
<p><code>40.class</code></p>

</div>
<div class='slide '>
<h1>Clases &amp; Métodos</h1><p>Aprendamos la sintaxis mediante un ejemplo:</p>
<pre><code>class Counter
end</code></pre>
<p>Qué podemos hacer con <code>Counter</code>?</p>
<p><code>c = Counter.new</code></p>

</div>
<div class='slide '>
<h1>Clases &amp; Métodos</h1><p>Aprendemos la sintaxis mediante un ejemplo:</p>
<pre><code>class Counter
attr_accessor :value
end</code></pre>
<p>Ahora intentemos</p>
<pre><code>c = Counter.new
c.value
c.value = 10
c.value</code></pre>
<p>Qué pasa? Que es lo que hace <code>attr_accessor :value</code> ?</p>

</div>
<div class='slide '>
<h1>Clases &amp; Métodos</h1><p>Aprendemos la sintaxis mediante un ejemplo:</p>
<pre><code>class Counter
  attr_accessor :value</code>

<code>  def initialize
    @value = 0
  end
end</code></pre>
<p>Nuevamente</p>
<pre><code>c = Counter.new
c.value</code></pre>
<p><code>initialize</code> le da instrucciones a <code>new</code> de como crear un objeto</p>

</div>
<div class='slide '>
<h1>Clases &amp; Métodos</h1><p>Aprendamos la sintaxis mediante un ejemplo:</p>
<pre><code>class Counter
  attr_accessor :value</code>

<code>  def initialize
    @value = 0
  end</code>

<code>  def increment
    @value = @value + 1
  end
end</code></pre>

</div>
<div class='slide '>
<h1>Clases &amp; Métodos</h1><p>Estas definiciones de un método son equivalentes:</p>
<pre><code>
  def increment x
    x + 1
  end</code>

<code>  def increment(x)
    return x + 1;
  end</code>

<code>  def increment(x); x + 1; end</code></pre>

</div>
<div class='slide '>
<h1>Clases</h1><p>Usemos nuestra clase Counter:</p>
<pre><code>count = Counter.new
count.increment
count.increment
count.value</code></pre>
<pre><code>count.class
count.methods.sort
count.respond_to?(:increment)</code></pre>

</div>
<div class='slide '>
<h1>Ejercicio</h1><p>Vamos a agregar un método <code>Counter.increment_by</code> que tome un <strong>argumento</strong> por el cual incrementar el contador.</p>
<p>No hay que empezar desde cero; podemos sólo <strong>abrir</strong> la clase</p>
<pre><code>class Counter</code>

<code>def increment_by(n)
  # fill in here
end</code>

<code>end</code></pre>
<p>Prueba el código que escribiste:</p>
<pre><code>c = Counter.new
c.increment_by(5)
c.value</code></pre>

</div>
<div class='slide '>
<h1>Clases</h1><p>También se puede agregar métodos a clases ya existentes:</p>
<pre><code>class String
  def chicken?
    self == "chicken"
  end
end</code></pre>
<pre><code>"chicken".chicken?
"puppy".chicken?</code></pre>
<p><code>self</code> es una forma de referirse al objeto del cual el método se esta llamando.</p>
<p>En <code>"puppy".chicken?</code>, <code>self</code> es <code>"puppy"</code>.</p>

</div>
<div class='slide '>
<h1>Clases</h1><p>Si aún no lo han hecho, escriban la clase Counter en su editor favorito y guardenlo en disco. Levantemoslo en la consola de ruby.</p>
<pre><code>class Counter
  attr_accessor :value
  def initialize
    @value = 0
  end
  def increment
    @value = @value + 1
  end
  def increment_by(n)
    @value = @value + n
  end</code></pre>
<p>En la consola: <code>require 'path_to_your_file'</code></p>

</div>
<div class='slide '>
<h1>Modulos</h1><p>Un módulo es básicamente una clase que no puede ser instanciada.</p>

</div>
<div class='slide '>
<h1>Control de Acceso</h1><p>Ruby tiene tres niveles de protección para constantes y mteodos de clase y modulo.</p>
<ul>
	<li>public. Accesible para todo el mundo.</li>
	<li>protected. Puede ser sólo invocado por objetos la clase definida y sus subclases.</li>
	<li>private. Puede ser solo llamado en una forma funcional (con un self implicito). Por lo tanto métodos privados solo pueden ser llamados en la clase definida y por los ancestros y descendientes de la clase, pero solo dentro del mismo objeto.</li>
</ul>

</div>
<div class='slide '>
<h1>Testing</h1><p>Automatizar cualquier tarea que se pueda hacer más de una vez es una sabia decisión.</p>
<ul>
	<li>no tener que pasar horas buscando un bug en el código que se escribio hace meses</li>
	<li>escribir codigo mas robusto y de mejor calidad</li>
	<li>el código se hace más mantenible</li>
	<li>más productividad a largo plazo sobre la aplicación</li>
</ul>

</div>
<div class='slide '>
<h1>Testing</h1><p>Ahora escribiremos una clase para testearlo automáticamente.</p>
<pre><code>require 'test/unit'
  require 'counter'
  class TestCounter &lt; Test::Unit::TestCase
    def test_increment
      assert_equal(1, Counter.new().increment())
    end
  end</code></pre>
<p>Escribanlo en un archivo test_counter.rb y ejecutenlo.</p>

</div>
<div class='slide '>
<h1>Ejercicio</h1><p>Escribir un test para increment_by.</p>

</div>
<div class='slide '>
<h1>Ejercicio</h1><p>Agregar un método a String que devuelva si un string es palindromo o no.</p>
<p>Un palindromo es cualquier cadena de caracteres que se lea igual de adelante para atras que de atras para adelante.</p>
<p>Para empezar tipear lo siguiente en la linea de comandos:</p>
<pre><code>class String
  def palindrome?</code></pre>
<p>y terminarlo! Pruebenlo con <code>"abba".palindrome?</code> y <code>"puppy".palindrome?</code></p>

</div>
<div class='slide '>
<h1>Más sobre las clases nativas de Ruby</h1><p><a href="http://rubydoc.info/stdlib/core">http://rubydoc.info/stdlib/core/</a></p>
<p>Otras son: Array, Enumerable, Fixnum, Float, Hash, NilClass, String, Time</p>

</div>
<div class='slide '>
<h1>Bloques</h1><p>Algunos métodos también pueden tener asociados bloques como si fueran parametros.</p>
<p><code>list.each {|p| code}</code> corre <code>code</code> en cada elemento de <code>list</code></p>
<pre><code>list = [1,2,3,4]
list.each { |n| puts (n + 1) }</code></pre>
<ul>
	<li>Un <strong>bloque</strong> es un pedazo de código asociado a un contexto de variables.</li>
	<li>Puede tener dos sintaxis
	<ul>
		<li>Cuando es sólo una linea <code>{ |arg1, arg2, ..| code }</code></li>
		<li><code>{ |v| v.palindrome? }</code></li>
		<li><code>{ |x, y| x * y }</code></li>
		<li>Cuando es más de una linea 
bc.. do |arg|
    code
  end</li>
	</ul></li>
</ul>

</div>
<div class='slide '>
<h1>Bloques</h1><p>Para nuestro ejemplo de los libros.</p>
<pre><code>reviews = Hash.new(0)
books.values.each { |rate| reviews[rate] = reviews[rate] + 1 }
reviews</code></pre>
<p>Qué contiene <code>reviews</code>?</p>
<p><code>reviews[5]</code></p>

</div>
<div class='slide '>
<h1>Bloques</h1><p>Y en caso que el bloque tenga más de una linea</p>
<pre><code>reviews = Hash.new(0)
books.values.each do |rate|
  reviews[rate] = reviews[rate] + 1
  # more code can go here...
end</code></pre>

</div>
<div class='slide '>
<h1>Bloques y Callbacks</h1><p>Se pueden usar bloques para implementar callbacks, para pasar pedazos de código e implementar iteradores.</p>
<p>Por ejemplo,</p>
<pre><code>def call_block
  puts "Comienzo del método"
  yield
  yield
  puts "Fin del método"
end</code></pre>
<p><code>call_block { puts "En el bloque" }</code> produce:</p>
<pre><code>Comienzo del método
En el bloque
En el bloque
Fin del método</code></pre>
<p>yield invoca al bloque asociado con la llamada al método que lo contiene</p>

</div>
<div class='slide '>
<h1>Lambdas y Procs</h1><p>Los bloques no son objetos pero pueden ser convertidos en objectos mediante la clase Proc.  Hay varias formas de convertir un bloque en un objeto Proc:</p>
<ul>
	<li>Pasando un bloque a un método cuyo último parametro es prefijado con un ampersand.</li>
</ul>
<pre><code>def método(p1, p2, &amp;bloque)
  puts bloque.inspect
end
método(1,2) { "un bloque" }
método(3,4)</code></pre>
<ul>
	<li>Llamando Proc.new</li>
</ul>
<pre><code>Proc.new{ "un bloque" }</code></pre>

</div>
<div class='slide '>
<h1>Lambdas y Procs</h1><ul>
	<li>Llamando a el método Object#lambda asocia un bloque con la llamada lambda{ &#8220;un bloque&#8221; }</li>
</ul>
<ul>
	<li>En 1.9 usando la sintaxis</li>
</ul>
<pre><code>lam =-&gt;(p1,p2) {p1 + p2}
lam.call(4,3)</code></pre>

</div>
<div class='slide '>
<h1>Lambdas y Procs</h1><p>Diferencias entre Procs y Lambdas:</p>
<ul>
	<li>Return keyword.
	<ul>
		<li>En un lambda, return retorna desde el lambda.</li>
		<li>En un proc el return retorna desde el alcance donde el proc fue definido.</li>
	</ul></li>
	<li>Argumentos.
	<ul>
		<li>Si se llama a un lambda con una aridad incorrecta entonces falla con ArgumentError.</li>
		<li>Los Proc son más flexibles y toman la cantidad de argumentos necesaria llenando los no dados con nil.</li>
	</ul></li>
</ul>

</div>
<div class='slide '>
<h1>Estructuras de Control</h1><p>Ruby provee las clasicas estructuras de control como los if y while loops.</p>
<p>Sintaxis if</p>
<pre><code>if true
  1
else 
  2
end</code></pre>
<p>ó</p>
<pre><code>código if true</code></pre>

</div>
<div class='slide '>
<h1>Estructuras de control</h1><p>Sintaxis while</p>
<pre><code>while true
  do some code
end</code></pre>
<p>ó</p>
<pre><code>some_code while true</code></pre>

</div>
<div class='slide '>
<h1>Iteradores</h1><pre><code>3.times{ puts "Hola mundo!" }</code></pre>
<pre><code>5.downto(1){|i| puts "Cuenta regresiva #{i}."}</code></pre>
<pre><code>animals = ["gato", "perro", "caballo"]
animals.each do |animal|
  puts "Tenemos un #{animal}."
end</code></pre>
<pre><code>my_hash = {:type =&gt; "cat",
              :name =&gt; "Beckett",
	      :breed =&gt; "alley cat"}
my_hash.each do |key, value|
  puts "My #{key.to_s} is #{value}" 
end</code></pre>
<pre><code>my_hash.each_pair{|k,v| puts "key: #{k} con su valor #{v}"}</code></pre>

</div>
<div class='slide '>
<h1>Expresiones Regulares</h1><ul>
	<li>Ruby las tiene nativo en el lenguaje</li>
	<li>La sintaxis es /pattern/</li>
	<li>Una expresión regular también es un objeto. Son instancias de la clase Regexp</li>
</ul>
<p>Por ejemplo, /P(ython|erl)/ matchea los strings que contengan Python o Perl</p>

</div>
<div class='slide '>
<h1>Excepciones</h1><p>Información de una excepción viene encapsulada en un objeto de clase Exception o alguno de sus &#8220;hijos&#8221;.</p>
<p>Para manejar excepciones:</p>
<pre><code>begin
# .. procesar
rescue
# .. manejar el error
ensure
# ..codigo que siempre se ejecuta (por ejemplo f.close para un archivo f)
end</code>

<code>Para levantar excepciones con Object#raise :</code></pre>
<pre><code>raise ArgumentError, "Name too big", caller</code></pre>

</div>
<div class='slide '>
<h1>Ruby Koans</h1><p>Son ejercicios para aprender/practicar Ruby. Aconsejables para cualquier nivel. Tiene también ejercicios sobre metaprogramación.</p>
<p>Descargarlos desde &#8220;http://rubykoans.com/&#8221;http://rubykoans.com</p>

</div>
<div class='slide '>
<h1>Descanso para el Almuerzo</h1></div>
<div class='slide '>
<h1>Introduccion a Rails</h1><ul>
	<li>Rails es un framework para construir aplicaciones web</li>
	<li>Está estructurado usando una arquitectura llamada MVC: Model-View-Controller</li>
	<li>MVC separa diferentes partes de la lógica de la aplicación en secciones en función de para que son usadas.</li>
</ul>

</div>
<div class='slide '>
<h1>¿Por qué Rails?</h1><ul>
	<li>Convenciones sobre configuraciones
	<ul>
		<li>Crear una aplicación Web implica tomar muchas decisiones.</li>
		<li>Rails tiene una opinión sobre cómo habria que desarrollar aplicaciones web.</li>
		<li>Esto hace que algunas las tareas que sigan sus convenciones sean muy sencillas (y las que no sigan las convenciones de Rails lleven un poco más de trabajo)</li>
	</ul></li>
</ul>
<ul>
	<li>Comunidad y Herramientas
Existe una comunidad muy activa entorno a Rails y podemos aprovecharla para consultar y usar las herramientas desarrolladas.</li>
</ul>
<p>Escribir en una consola:</p>
<ol>
	<li><code>cd microrant</code></li>
	<li><code>bundle install</code></li>
	<li><code>rake db:migrate</code></li>
	<li><code>rails server</code></li>
	<li>Abrir <a href="http://localhost:3000">http://localhost:3000</a> en tu navegador</li>
</ol>

</div>
<div class='slide '>
<h1>Microrant &#8211; (micro quejas)</h1><ul>
	<li>Twitter?</li>
	<li>10 caracteres para expresar tu ira</li>
	<li>Actividades basicas: create, read, update, delete (CRUD)</li>
	<li>Ir a http://localhost:3000/users/new para crear un nuevo usuario con tu nombre</li>
	<li>Luego ir a /rants/new y crear un nuevo rant
	<ul>
		<li>Rants también pueden ser editados y borrados!</li>
	</ul></li>
</ul>
<ul>
	<li>Qué hay detrás de escenas?
	<ul>
		<li>Rails trae clases que nos permiten obtener y manipular datos fácilmente</li>
		<li>La lógica de la aplicación se escribe en Ruby común y corrriente, y un modulo llamado ActiveRecord hace todo el trabajo de conexión a la base de datos</li>
	</ul></li>
</ul>

</div>
<div class='slide '>
<h1>En el Backstage</h1><p>Organización por defecto de Rails:</p>
<h2>app/</h2>
<p>&#8212;&gt; controllers/</p>
<p>&#8212;&gt; helpers/</p>
<p>&#8212;&gt; mails/</p>
<p>&#8212;&gt; models/</p>
<p>&#8212;&gt; views/</p>
<h2>config/</h2>
<p>&#8212;&gt; database.yml</p>
<p>&#8212;&gt; routes.rb</p>

</div>
<div class='slide '>
<h1>En La Consola</h1><ul>
	<li>Cerrar el servidor Rails con Ctrl-C</li>
	<li><code>rails console</code></li>
	<li>Puedes modificar los datos usando las clases <code>Rant</code> y <code>User</code></li>
	<li>La clase <code>User</code> tiene atributos <code>id</code> y <code>name</code></li>
	<li>La clase <code>Rant</code> tiene atributos <code>id</code>, <code>message</code> y <code>user_id</code></li>
</ul>

</div>
<div class='slide '>
<h1>En La Consola</h1><p>Como podemos ver un rant luego que fue creado?</p>
<pre><code>r = Rant.find(1)
r.message
r.user_id</code></pre>
<p>Y como podemos modificarlo?</p>
<pre><code>r.message = "RANTING!"
r.save</code></pre>
<p>Necesitamos guardar (<code>save</code>) los cambios luego que terminamos de editarlo.
Tambien podemos modificar directamente con <code>update_attribute(:message, "RANTING")</code>. Si quieren ver mas métodos, consulten la documentación de Rails.</p>

</div>
<div class='slide '>
<h1>Donde Estan Mis Cosas</h1><p>Los modelos en Rails tienen métodos de busqueda incorporados que ayuda a obtener los registros desde la base de datos.</p>
<ul>
	<li><code>Rant.all</code></li>
	<li><code>Rant.order("created_at DESC")</code></li>
	<li><code>Rant.first</code></li>
	<li><code>Rant.where("user_id = 1")</code></li>
	<li><code>Rant.where(:user_id =&gt; 1)</code></li>
	<li><code>Rant.where(:user_id =&gt; 1).order("created_at DESC")</code></li>
</ul>
<p>Observa la sentencia de SQL generado con el método <code>to_sql</code></p>

</div>
<div class='slide '>
<h1>En La Consola</h1><p>Intentemos crear un nuevo Rant para <code>user_id</code> 1</p>
<pre><code>
rant = Rant.new
rant.user = User.find(1)
rant.message = "WHAT IS TH"
rant.save</code></pre>
<p>No tuvimos que setearle el valor de <code>id</code> al mensaje!
Esto fue automaticamente hecho por <code>new</code>.</p>
<p>Guardamos (<code>save</code>) el registro cuando terminamos, para poder crearlo, al igual que cuando estabamos editándolo.</p>

</div>
<div class='slide '>
<h1>En la Consola</h1><p>Hay una mejor manera de crear un rant</p>
<p><code>User.find(1).rants.create(:message =&gt; "E POINT!?")</code></p>
<p>De esta forma no tenemos que usar save para guardar pues usamos <code>create</code>&#8212;quien combina <code>new</code> y <code>save</code> en un sólo paso.</p>

</div>
<div class='slide '>
<h1>Mirando a los Modelos</h1><p>Abrir los archivos user.rb y rant.rb en el directorio <code>models/</code></p>
<pre><code>class Rant &lt; ActiveRecord::Base
  belongs_to :user</code>

<code>  validates :user, :presence =&gt; true
  validates :message, :presence =&gt; true, :length =&gt; { :maximum =&gt; 10 }
end</code></pre>

</div>
<div class='slide '>
<h1>Mirando a los Modelos (User)</h1><pre><code>class User &lt; ActiveRecord::Base
  has_many :rants</code>

<code>  validates :name, :presence =&gt; true
end</code></pre>

</div>
<div class='slide '>
<h1>Ejercicios</h1><p>Algunas personas están escribiendo rants en minúsculas!</p>
<p>Vamos a escribir un método para convertir todos los rants a mayúsuculas. 
Primero encuentren el archivo rant.rb en el directorio de modelos de Rails.</p>
<pre><code>
class Rant &lt; ActiveRecord::Base
  before_save :convert_message_to_uppercase
  def convert_message_to_uppercase
  ...</code>

<code>Rails tiene muchas extensiones a las clases de Ruby para hacer que las tareas comunes sean sencillas. Miren en "http://api.rubyonrails.org/classes/ActiveSupport/Multibyte/Chars.html":http://api.rubyonrails.org/classes/ActiveSupport/Multibyte/Chars.html y encuentren el helper que necesitan para este ejercicio.</code>

<code>Una vez que lo hicieron prueben escribir un rant en minúsculas para ver qué pasa.
Esta vez utilicen un método de Ruby? Miren en: "http://www.ruby-doc.org/core-1.9.2/String.html":http://www.ruby-doc.org/core-1.9.2/String.html y busquen si hay un método de instancia que permite pasar a minúsculas un String.</code></pre>

</div>
<div class='slide '>
<h1>Ejercicios</h1><p>Pueden querer trabajar con sus datos en algún otro formato. Vuelvan a la consola de Rails y escriban un programa que cree un hash que contenga mensajes rant junto con el nombre del usuario que lo escribió.</p>
<p>Como era que se creaba un Hash?</p>
<ul>
	<li>Vimos <code>Hash.new</code> pero también se puede crear con <code>{}</code>.</li>
	<li>Intenta <code>new_hash = {}</code></li>
</ul>
<p>El resultado debería ser algo como:</p>
<pre><code>=&gt; {"RANTING!"=&gt;"caylee", "WTF"=&gt;"audrey"}</code></pre>
<p>Pueden usar un iterador para mostrarlo como una serie de strings formateados?</p>

</div>
<div class='slide '>
<h1>Callbacks</h1><p>El código que aparece en <code>before_save</code> usa un <strong>callback</strong>. Rails define varios callbacks que nos permiten cambiar la entrada a un modelo antes o después de acciones como save, create, update y delete.</p>
<pre><code>before_save :geocode_address
after_create :notify_admins
before_validate :check_over_some_other_details</code></pre>

</div>
<div class='slide '>
<h1>Control de Calidad</h1><p>Las validaciones dan un wrapper sencillo para chequear si un atributo en particular está presente, si esta en el formato correcto u otros requerimientos antes que la aplicación guarde los datos. La aplicación de microrant ya tiene algunos de éstos. Miren en los modelos <code>Rant</code> y <code>User</code> para ver cuáles hemos incluído.</p>
<p>Pueden pensar de algunas otras validaciones que podamos querer usar? Intenten cambiar el largo de un mensaje de Rant válido.</p>

</div>
<div class='slide '>
<h1>Mostrando los Datos</h1><p>Rails automáticamente crea vistas con contenido usando el comando <code>scaffold</code>. Miren lo que tenemos en /app/views</p>
<p>Estos archivos usan el sistema de templating llamado ERB que convierte líneas de Ruby en la vista en HTML estático para desplegar. Una línea típica de ERB podria ser como esto:</p>
<p><code>5 + 1 = &lt; %= 5 + 1 %&gt;</code></p>
<p>Se vería así:</p>
<p><code>5 + 1 = 6</code></p>
<p>Documentación sobre la sintaxis de ERB: <a href="http://ruby-doc.org/stdlib/libdoc/erb/rdoc/classes/ERB.html">http://ruby-doc.org/stdlib/libdoc/erb/rdoc/classes/ERB.html</a></p>

</div>
<div class='slide '>
<h1>Ejercicio 1 (ERB)</h1><p>El sistema de scaffolding es rápido de usar, pero no siempre lindo. Nuestra lista de rants tiene al <code>user_id</code> para la persona que lo dijo pero no su nombre. Cambien eso.</p>
<p>Ir a <code>/app/views/rants/</code> y abran el archivo <code>index.html</code>. Por defecto, el scaffolder hace que la vista index muestre una lista de registros relacionados al tipo del modelo. Encuentren la línea que muestra el id del usuario y cámbienla para mostrar el nombre de usuario.</p>

</div>
<div class='slide '>
<h1>Ejercicio 2 (ERB)</h1><p>Modifiquen el archivo <code>index.html</code> de rants, para que muestre &#8220;No hay rants&#8221; en vez de la tabla, en caso de que no existan rants.</p>

</div>
<div class='slide '>
<h1>Ejercicio 3 (ERB)</h1><p>En la página <code>index</code> de usuarios, agreguemos una columna a la tabla para mostrar cuantos rants cada persona ha escrito. ActiveRecord hace que esto sea muy fácil con un método llamado <code>count</code> que se puede enviar a una colección de registros para obtener el count de la base de datos en vez de todos los registros. Por ejemplo <code>User.count</code> o <code>Rants.count</code>.</p>

</div>
<div class='slide '>
<h1>Layouts</h1><p>Ir a <code>app/views/layouts/application.html</code></p>
<ul>
	<li>En <code>application.html</code> está el template de la aplicación.</li>
	<li>Esta página es la que permite tener un esquema html común a todas las paginas</li>
	<li>El método <code>yield</code> pasa la ejecución al template que se quiere ver</li>
	<li>En este caso el template que hemos estado viendo es <code>index.html</code></li>
</ul>

</div>
<div class='slide '>
<h1>Layouts Especificos</h1><ul>
	<li>Crear un archivo en <code>app/views/layouts/users.html</code> y escribir:</li>
</ul>
<p>bc..

</div>
<div class='slide '>
<h1> Esto es solo para los Usuarios </h1>&lt; %= yield %&gt;</p>
<ul>
	<li>Ejemplo de convención sobre configuración</li>
</ul>

</div>
<div class='slide '>
<h1>Rutas</h1><p>Como sabe Rails que a que página ir cuando visitas <a href="http://localhost:3000/rants/new">http://localhost:3000/rants/new</a> ?</p>
<p>Rails primero busca las páginas estáticas en public/ y luego ejecutan las reglas</p>
<p>Abrir /config/routes.rb para ver como funciona.</p>

</div>
<div class='slide '>
<h1>Rutas</h1><p>Observar la linea <code>resources :users</code>
Ejecutar <code>rake routes</code> y analizar que devuelve? Como se relaciona con la linea de <code>routes.rb</code>?</p>

</div>
<div class='slide '>
<h1>Nos falta la C de MVC</h1><p>Ahora que hemos visto y editado modelos y vistas, vamos a ir a mirar los archivos de controladores en nuestro proyecto.</p>
<p>Qué hace un controlador?</p>
<ul>
	<li>Conecta la vista y el modelo, llamando a métodos en los modelos para obtener los datos necesitados en la vista y permitiendote acceder parametros de entrada como los de un formulario.</li>
	<li>Responde al request HTTP del navegador y renderea el tipo pedido de salida (en nuestros scaffolds es html o xml pero otros como json pueden ser facilmente agregandos &#8212; API instantanea!)</li>
	<li>También en el controlador es donde se deberia agregar los controles de acceso, como por ejemplo solo permitir que el usuario que escribio el rant pueda eliminarlo.</li>
</ul>

</div>
<div class='slide '>
<h1>Ejercicio</h1><p>Modificar el código para no permitir escribir más de 3 rants por dia.</p>

</div>
<div class='slide '>
<h1>Ejercicio &#8211; Solucion (Parte I)</h1><ul>
	<li>Agregar el siguiente código en el <code>users_controller.rb</code> de la carpeta <code>app/controllers</code></li>
</ul>
<p>bc..
  before_filter :no_quejarse_demasiado, :only =&gt; [:new, :create]</p>
def no_quejarse_demasiado
user = User.find(params[:id])
if user.rants.where(created_at &gt; 1.day.ago).count &gt; 3
redirect_to :index, :notice =&gt; &#8220;Has escrito demasiados rants hoy!&#8221;
end
end

</div>
<div class='slide '>
<h1>Ejercicio &#8211; Solución (Parte II)</h1><p>En <code>app/views/layouts/application.html.erb</code> agregar arriba de <code>yield</code></p>
<p>bc..
  <p>&lt; %= flash[:notice] %&gt;</p></p>

</div>
<div class='slide '>
<h1>Picando tu propio código</h1><ul>
	<li>Ir al directorio donde puedas crear una aplicación nueva de Rails</li>
	<li>Correr <code>rails new betterrant</code></li>
	<li>Ir al directorio creado <code>cd betterrant</code></li>
</ul>
<pre><code>bundle install
rails generate scaffold User name:string
rails generate scaffold Rant user_id:integer message:string
rake db:migrate</code></pre>
<p>En este momento puedes iniciar el servidor y mirar que hay</p>

</div>
<div class='slide '>
<h1>Resumen</h1><ul>
	<li>Hemos visto lo básico del lenguaje Ruby
	<ul>
		<li>Si quieren repasarlo, <a href="http://tryruby.org/">Try Ruby</a> es una aplicación web para jugar con Ruby</li>
	</ul></li>
</ul>

</div>
<div class='slide '>
<h1>Resumen</h1><ul>
	<li>Hemos aprendido sobre una pequeña aplicación Rails: microrants
	<ul>
		<li>Un tutorial que pueden mirar es <a href="http://railsforzombies.org/">Rails For Zombies</a></li>
		<li>Y en más detalle pueden encontrar <a href="http://guides.rubyonrails.org/">Ruby Guides</a></li>
		<li>ActiveRecord nos permite manipular datos persistidos como si fueran objetos comunes</li>
		<li>Los archivos .erb nos permiten integrar el código Ruby con html</li>
		<li>Scaffolding nos da una forma de automatizar el comienzo de un proyecto Rails</li>
	</ul></li>
</ul>

</div>
<div class='slide '>
<h1>Más Para Leer</h1><ul>
	<li>PickAxe es un clásico entre los libros para aprender Ruby. Pueden encontrarlo en <a href="http://pragprog.com">http://pragprog.com</a></li>
	<li>Web RubyLang para ver lo último de Ruby: <a href="http://www.ruby-lang.org">http://www.ruby-lang.org</a></li>
	<li>La documentación de Ruby <a href="http://www.ruby-doc.org">http://www.ruby-doc.org</a></li>
	<li>Meta Koans  http://www.rubyquiz.com/quiz67.html</li>
</ul>

</div>
<div class='slide '>
<h1>Grupos de Usuarios y Desarrolladores</h1><ul>
	<li>Participa en el grupo de Ruby de Uruguay. Comparte lista de correo con los usuarios de Ruby de América del Sur. http://rubysur.org/</li>
	<li>Otras listas de correo
	<ul>
		<li>ruby-talk@ruby-lang.org (en ingles)</li>
		<li>ruby-doc@ruby-lang.org (en ingles) sobre documentación</li>
		<li>ruby-core@ruby-lang.org (en ingles) sobre implemantación del core de ruby</li>
		<li>ruby-dev@ruby-lang.org (en ingles) para desarrolladores de ruby</li>
		<li>RubyConf Uruguay 2011 el próximo fin de semana.</li>
	</ul></li>
</ul>

</div>
<div class='slide '>
<h1>Contribuir con Ruby y con Rails</h1><ul>
	<li>Reportar Bugs en Ruby
	<ul>
		<li>El tracking system está en http://redmine.ruby-lang.org</li>
		<li>Antes de reportarlo navega los bugs ya reportados para ver si tu bug ya existe. También proba nuevas versiones de ruby por si eso lo soluciona.</li>
		<li>También es una buena idea enviar una pregunta sobre el bug a la lista de correo ruby-talk.</li>
		<li>Cuando envias un bug es una buena idea incluir el resultado de ejecutar ruby -v, el sistema operativo y además la problematica del código.</li>
	</ul></li>
	<li>Ayudar con la documentación
	<ul>
		<li>Hacer traducción</li>
		<li>Mejorar la documentación</li>
		<li>Hay un sistema llamado RDoc</li>
		<li>ri es un visor en la consola para esa misma documentación. Tipea ri ClassName para encontrar la documentación de esa clase</li>
	</ul></li>
</ul></div>


  </div> <!-- presentation -->
</body>
</html> 

